
variables:
  fatsDir: '$(system.defaultWorkingDirectory)/../fats'
  fatsRefspec: dac0129e000dd711a74202ba95d6b547e64d8f66 # projectriff/fats master as of 2019-06-20
  duffleNamespace: kube-system
  duffleServiceAccount: duffle-runtime

jobs:
- job: test_pr
  pool:
    vmImage: 'ubuntu-16.04'
  condition: and(succeeded(), eq(variables['Build.Reason'], 'PullRequest'))
  variables:
    CLUSTER: minikube
    REGISTRY: minikube
    CLUSTER_NAME: 'cnab-$(Build.BuildId)-minikube'
    NAMESPACE: 'cnab-$(Build.BuildId)-minikube'
    NODE_PORT: 'true'
  steps:
  - bash: ./ci/fats-fetch.sh $(fatsDir) $(fatsRefspec) projectriff/fats
    displayName: 'Fetch FATS'
  - bash: |
      $(fatsDir)/install.sh kubectl
      $(fatsDir)/install.sh riff
      $(fatsDir)/install.sh duffle 0.2.0-beta.1-auth https://storage.googleapis.com/projectriff/internal/duffle
    displayName: 'Install tools'
  - script: duffle init && duffle build .
    displayName: 'Build bundle'
  - script: $(fatsDir)/start.sh
    displayName: 'Start FATS'
  - bash: |
      kubectl create serviceaccount "${SERVICE_ACCOUNT}" -n "${KUBE_NAMESPACE}"
      kubectl create clusterrolebinding "${SERVICE_ACCOUNT}-cluster-admin" --clusterrole cluster-admin --serviceaccount "${KUBE_NAMESPACE}:${SERVICE_ACCOUNT}"
      duffle install myriff riff -s node_port=${NODE_PORT} -d k8s
    env:
      KUBE_NAMESPACE: '$(duffleNamespace)'
      SERVICE_ACCOUNT: '$(duffleServiceAccount)'
    displayName: 'Install riff'
  - bash: ./ci/run-tests.sh
    displayName: 'Run tests'
    env:
      FATS_DIR: $(fatsDir)
      FATS_REFSPEC: $(fatsRefspec)
  - bash: ci/diagnostics.sh
    condition: failed()
    displayName: 'Collect diagnostics'
  - bash: duffle uninstall myriff -d k8s
    env:
      KUBE_NAMESPACE: '$(duffleNamespace)'
      SERVICE_ACCOUNT: '$(duffleServiceAccount)'
    condition: always()
    displayName: 'Uninstall riff'
  - bash: $(fatsDir)/cleanup.sh
    condition: always()
    displayName: 'Cleanup FATS'
  displayName: 'Test PR'

- job: stage
  pool:
    vmImage: 'ubuntu-16.04'
  condition: and(succeeded(), ne(variables['Build.Reason'], 'PullRequest'))
  steps:
  - bash: ./ci/fats-fetch.sh $(fatsDir) $(fatsRefspec) projectriff/fats
    displayName: 'Fetch FATS'
  - bash: |
      $(fatsDir)/install.sh duffle 0.2.0-beta.1-auth https://storage.googleapis.com/projectriff/internal/duffle
      $(fatsDir)/install.sh gcloud
      ./ci/stage-bundle.sh
    env:
      DOCKER_USERNAME: '$(DockerUsername)'
      DOCKER_PASSWORD: '$(DockerPassword)'
      GCLOUD_CLIENT_SECRET: '$(GcloudClientSecret)'
    displayName: 'Stage riff bundle'
  displayName: 'Stage'

- job: test
  dependsOn: stage
  strategy:
    matrix:
      minikube:
        imageName: ubuntu-16.04
        qualifier: minikube
        cluster: minikube
        registry: dockerhub
        nodePort: 'true'
      gke:
        imageName: ubuntu-16.04
        qualifier: gke
        cluster: gke
        registry: gcr
        nodePort: 'false'
  pool:
    vmImage: $(imageName)
  variables:
    CLUSTER:  '$(cluster)'
    REGISTRY: '$(registry)'
    CLUSTER_NAME: 'cnab-$(Build.BuildId)-$(qualifier)'
    NAMESPACE: '$(CLUSTER_NAME)'
    NODE_PORT: '$(nodePort)'
  condition: and(succeeded(), ne(variables['Build.Reason'], 'PullRequest'))
  steps:
  - bash: ./ci/fats-fetch.sh $(fatsDir) $(fatsRefspec) projectriff/fats
    displayName: 'Fetch FATS'
  - bash: |
      $(fatsDir)/install.sh kubectl
      $(fatsDir)/install.sh riff
      $(fatsDir)/install.sh duffle 0.2.0-beta.1-auth https://storage.googleapis.com/projectriff/internal/duffle
      $(fatsDir)/install.sh gcloud
    displayName: 'Install tools'
    env:
      GCLOUD_CLIENT_SECRET: '$(GcloudClientSecret)'
  - bash: $(fatsDir)/start.sh
    displayName: 'Start FATS'
    env:
      DOCKER_USERNAME: '$(DockerUsername)'
      DOCKER_PASSWORD: '$(DockerPassword)'
      GCLOUD_CLIENT_SECRET: '$(GcloudClientSecret)'
  - bash: |
      version=`cat VERSION`
      commit=$(git rev-parse HEAD)
      file=riff-bundle-${version}-${commit}.json
      curl -O https://storage.googleapis.com/projectriff/riff-cnab/builds/${file}
      kubectl create serviceaccount "${SERVICE_ACCOUNT}" -n "${KUBE_NAMESPACE}"
      kubectl create clusterrolebinding "${SERVICE_ACCOUNT}-cluster-admin" --clusterrole cluster-admin --serviceaccount "${KUBE_NAMESPACE}:${SERVICE_ACCOUNT}"
      duffle install myriff ${file} --bundle-is-file -s node_port=${NODE_PORT} -d k8s
    env:
      KUBE_NAMESPACE: '$(duffleNamespace)'
      SERVICE_ACCOUNT: '$(duffleServiceAccount)'
      COMPOSE_CONVERT_WINDOWS_PATHS: 1
    displayName: 'Install riff'
  - bash: ./ci/run-tests.sh
    displayName: 'run fats'
    env:
      DOCKER_USERNAME: '$(DockerUsername)'
      DOCKER_PASSWORD: '$(DockerPassword)'
      GCLOUD_CLIENT_SECRET: '$(GcloudClientSecret)'
      FATS_DIR: $(fatsDir)
      FATS_REFSPEC: $(fatsRefspec)
  - bash: ci/diagnostics.sh
    condition: failed()
    displayName: 'Collect diagnostics'
  - bash: duffle uninstall myriff -d k8s
    env:
      KUBE_NAMESPACE: '$(duffleNamespace)'
      SERVICE_ACCOUNT: '$(duffleServiceAccount)'
    condition: always()
    displayName: 'Uninstall riff'
  - bash: $(fatsDir)/cleanup.sh
    env:
      DOCKER_USERNAME: '$(DockerUsername)'
      DOCKER_PASSWORD: '$(DockerPassword)'
    condition: always()
    displayName: 'Cleanup FATS'
  displayName: 'Test'

- job: publish
  dependsOn: test
  pool:
    vmImage: 'Ubuntu-16.04'
  condition: |
    and(
      succeeded(),
      ne(variables['Build.Reason'], 'PullRequest'),
      eq(variables['Build.SourceBranch'], 'refs/heads/master')
    )
  steps:
  - bash: ./ci/fats-fetch.sh $(fatsDir) $(fatsRefspec) projectriff/fats
    displayName: 'Fetch FATS'
  - bash: $(fatsDir)/install.sh gcloud
    env:
      GCLOUD_CLIENT_SECRET: '$(GcloudClientSecret)'
    displayName: 'Install gcloud'
  - bash: ./ci/publish.sh release
    displayName: 'Publish bundle'
  displayName: 'Publish'
